/* 
**  mod_authz_resource.c -- Apache sample provider_test module
**  [Autogenerated via ``apxs -n provider_test -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_authz_resource.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /provider_test in as follows:
**
**    #   httpd.conf
**    LoadModule provider_test_module modules/mod_authz_resource.so
**    <Location /provider_test>
**    SetHandler provider_test
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /provider_test and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/provider_test 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_authz_resource.c
*/ 




/**
 *
 * TO-DO:
 *
 * Merge mod_authz_resource_grouplookup_file with mod_authz_resource_file
 * basically get the groupfile lookup stuff in there rather than that 
 * fixed array of groups
 *
 * Implement resource file reading function. base it on the groupfile reading
 * function as its basically the same process. Dont forget it reads the file
 * r->filename+".priv"
 *
 * TEST TEST TEST TEST!
 *
 */





#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_protocol.h"
#include "http_log.h"
#include "ap_config.h"
#include "ap_provider.h"
#include "http_main.h"


#include "apr_strings.h"
#include "apr_tables.h"

#include "mod_authz_resource_permissions.h"
#include "mod_authz_resource_grouplookup.h"

/**
 *
 * NOTES
 *
 * TO-DO:
 *
 * Sort out of provider assigning directive
 *
 */

#define ARRAY_INIT_SZ           10



/**
 *
 * provider_test_config_rec
 *
 * This structure holds the initial directory config details
 *
 **/
typedef struct {
	const char* permissions_provider_name;
	const char* grouplookup_provider_name;
	const char *permissions_resource_suffix;
    char *dir;
    int authoritative;
    int flag;
    int auth_required;
    resource_permissions_t *permissions;
    apr_table_t *authorized_methods;
} provider_test_config_rec;


/**
 *
 * loadPermissionsProvider
 *
 * Does what it says on the tin. Loads up the permissions provider
 * and returns a reference to the provider.
 *
 */
static authz_resource_permissions_provider* loadPermissionsProvider(request_rec *r, 
														provider_test_config_rec *conf)
{
	authz_resource_permissions_provider *provider;
	provider = apr_pcalloc(r->pool, sizeof(authz_resource_permissions_provider));
	
	provider = ap_lookup_provider(AUTHZ_RESOURCE_PERMISSIONS_PROVIDER_GROUP,
                                        conf->permissions_provider_name, "0");
                                        
    if (provider == NULL) {
        /* by the time they use it, the provider should be loaded and
           registered with us. */
        ap_rprintf(r, "Failed to load permissions provider %s", conf->permissions_provider_name);
        return NULL;
    }

    if (!provider->get_permissions_by_uri) {
        /* if it doesn't provide the appropriate function, reject it */
        ap_rprintf(r, "The '%s' permissions provider doesn't support " "get_permissions_by_uri", 
        		conf->permissions_provider_name);
        return NULL;
    }
    
    return provider;
}

/**
 *
 * loadGrouplookupProvider
 *
 * Does what it says on the tin. Loads up the grouplookup provider
 * and returns a reference to the provider.
 *
 */
static authz_resource_grouplookup_provider* loadGrouplookupProvider(request_rec *r, 
														provider_test_config_rec *conf)
{
	authz_resource_grouplookup_provider *provider;
	provider = apr_pcalloc(r->pool, sizeof(authz_resource_grouplookup_provider));
	
	provider = ap_lookup_provider(AUTHZ_RESOURCE_GROUPLOOKUP_PROVIDER_GROUP,
                                        conf->grouplookup_provider_name, "0");
                                        
    if (provider == NULL) {
        /* by the time they use it, the provider should be loaded and
           registered with us. */
        ap_rprintf(r, "Failed to load grouplookup provider %s", conf->grouplookup_provider_name);
        return NULL;
    }

    if (!provider->get_groups_by_username) {
        /* if it doesn't provide the appropriate function, reject it */
        ap_rprintf(r, "The '%s' grouplookup provider doesn't support " "get_groups_by_username", 
        		conf->grouplookup_provider_name);
        return NULL;
    }

    return provider;
}


/**
 *
 * create_provider_test_dir_config
 *
 * This function is called to create the initial directory config.
 * Think of this as setting the default values for the config struct.
 *
 **/
static void *create_provider_test_dir_config(apr_pool_t *p, char *d)
{

    provider_test_config_rec *conf = apr_pcalloc(p, sizeof(*conf));

    conf->permissions_provider_name = AUTHZ_RESOURCE_PERMISSIONS_DEFAULT_PROVIDER;
    conf->grouplookup_provider_name = AUTHZ_RESOURCE_GROUPLOOKUP_DEFAULT_PROVIDER;
    conf->permissions_resource_suffix = ".permissions";
    conf->dir = d;
    
    /* Any failures are fatal. */
    conf->authoritative = 1;
	conf->flag = 0;
	
	conf->auth_required = 0;
	conf->authorized_methods = apr_table_make(p, 15);

    return conf;
}


module AP_MODULE_DECLARE_DATA authz_resource_module;

/**
 *
 * permissions_provider_conf
 *
 * This function is called whenever a directory contains the 
 * directive "AuthzResourcePermissionsProvider". This function
 * reads in the deafult config struct and overrides the default
 * values.
 *
 */
static const char *permissions_provider_conf(cmd_parms *cmd, void *config,
                                      	const char *arg)
{
	//provider_test_config_rec *s_cfg = ap_get_module_config(cmd->server->module_config, 
	//														&authz_resource_module);
  	//s_cfg->permissions_provider_name = (char *) arg;

	((provider_test_config_rec*)config)->permissions_provider_name = arg;

	return NULL;
}

/**
 *
 * grouplookup_provider_conf
 *
 * This function is called whenever a directory contains the 
 * directive "AuthzResourceGroupLookupProvider". This function
 * reads in the deafult config struct and overrides the default
 * values.
 *
 */
static const char *grouplookup_provider_conf(cmd_parms *cmd, void *config, 
										const char *arg)
{
//	provider_test_config_rec *s_cfg = ap_get_module_config(cmd->server->module_config, 
//															&authz_resource_module);
  //	s_cfg->grouplookup_provider_name = (char *) arg;
  	
	ap_log_error(APLOG_MARK, APLOG_INFO, 0, cmd->server, "This is in grouplookup_provider config: %s", arg);
	
	((provider_test_config_rec*)config)->grouplookup_provider_name = arg;
	return NULL;
}

static const char *permissions_resource_suffix_conf(cmd_parms *cmd, void *config, 
										const char *arg)
{
	((provider_test_config_rec*)config)->permissions_resource_suffix = arg;
	return NULL;
}

/**
 *
 * provider_test_cmds
 *
 * Directive initialisation
 *
 */
static const command_rec authz_resource_cmds[] =
{
    AP_INIT_TAKE1("AuthzResourcePermissionsProvider", permissions_provider_conf, 
    				NULL, OR_ALL,
                    "specify the provider used when looking up a resources permissions metadata"),
    AP_INIT_TAKE1("AuthzResourceGroupLookupProvider", grouplookup_provider_conf, 
    				NULL, OR_ALL,
                    "specify the provider used when looking up the groups the user is a member of"),
    AP_INIT_TAKE1("AuthzPermissionsResourceSuffix", permissions_resource_suffix_conf, 
    				NULL, OR_ALL,
                    "specify the suffix when requesting the permissons as a resource"),
    AP_INIT_FLAG("AuthzOwnerAuthoritative", ap_set_flag_slot,
                 (void *)APR_OFFSETOF(provider_test_config_rec, authoritative),
                 OR_AUTHCFG,
                 "Set to 'Off' to allow access control to be passed along to lower modules. (default is On.)"),
    {NULL}
};

int iterate_func(void *req, const char *key, const char *value) {
    int stat;
    char *line;
    request_rec *r = (request_rec *)req;
    if (key == NULL || value == NULL || value[0] == '\0')
        return 1;
    
    line = apr_psprintf(r->pool, "%s => %s\n", key, value);
    stat = ap_rputs(line, r);
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
					  "Permissions: %s", line);

    return 1;
}

int iterate_over_permissions(void *req, const char *key, const char *value) {
    int stat;
    char *line;
    request_rec *r = (request_rec *)req;
    if (key == NULL || value == NULL || value[0] == '\0')
        return 1;
    
    line = apr_psprintf(r->pool, "%s ", key);
    stat = ap_rputs(line, r);
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
					  "Permissions: %s", line);

    return 1;
}

int iterate_allowed_methods(void *req, const char *key, const char *value) {
    char *line;
    request_rec *r = (request_rec *)req;
    if (key == NULL || value == NULL || value[0] == '\0')
        return 1;
    
    line = apr_psprintf(r->pool, "%s", key);
	apr_table_merge(r->headers_out, "Allow", line);
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
					  "ALLOW: %s", line);

    return 1;
} 


static int content_handler(request_rec *r)
{
    provider_test_config_rec *conf = ap_get_module_config(r->per_dir_config,
                                                       &authz_resource_module);

    if (r->method_number == M_OPTIONS) {
		
		if (!strcmp(r->filename, "*")) {
			// We dont deal with server-wide options requests, only resource based ones 
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
						  "DOESNT SUPPORT SERVER-WIDE OPTIONS REQUESTS");
			return DECLINED;
		}
	
		// Output header
		apr_table_do(iterate_allowed_methods, r, conf->authorized_methods, NULL);
		
		// Output message body (needs work)
		apr_table_do(iterate_func, r, conf->authorized_methods, NULL);
		return OK;

	} else if (r->method_number == M_GET && !strcmp(r->handler, "permissions-handler")) {

		if (strcmp(r->handler, "permissions-handler")) {
			return DECLINED;
		}

		ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
							  "BINGO BANGO");

		
		// Here, we need to call the whole permissions grabbing stuff
		// again, but for the current url - the length of the permissions
		// file extention (/bob.permissions becomes /bob)
		// Because we want the permissions of the file bob.permissions
		// refers to, NOT the permissions of bob itself.
		// that would be /bob.permissions.permissions
		// That way, we can use the module to determine who can get the 
		// permissions file (and maybe PUT or POST permissions files in future)
	
		authz_resource_permissions_provider *permissions_provider = loadPermissionsProvider(r, conf);
		size_t s;
		char *target_uri;
		apr_status_t status;
		
		if (permissions_provider == NULL) {
			authz_resource_permissions_provider *permissions_provider = loadPermissionsProvider(r, conf);
			if (permissions_provider == NULL) {
				ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
							  "Content-handler: Permissions provider not set");
				return HTTP_INTERNAL_SERVER_ERROR;
			} 
		}
	
		// Create a new permissions conatiner
		resource_permissions_t *target_permissions;

		// get the url of the resource we want the 
		// permissions struct for:
		s = strlen(r->uri)-strlen(conf->permissions_resource_suffix);
		target_uri = apr_pstrndup(r->pool, r->uri, s);
		ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
						  "Target URI from content-handler: %s", target_uri);
	
		// Requires modification to get_permissions_by_uri
		// as it assumes the uri to fetch is the r->uri, which 
		// is not necessarily true (in this instance, at least)
		status = permissions_provider->get_permissions_by_uri(r, target_uri, &target_permissions);
		if (status != APR_SUCCESS) {
			ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
						  "Content-handler: Could not retrieve permissions for %s", target_uri);
			return HTTP_INTERNAL_SERVER_ERROR;
		}
		
		ap_set_content_type(r, "text/plain;charset=ascii");
	
		ap_rprintf(r, "URI: %s\n", target_uri);
		
		ap_rprintf(r, "Owner: %s\nGroup: %s\n", 
					target_permissions->owner, target_permissions->group);
		
		ap_rprintf(r, "Owner Permissions: "); 
		apr_table_do(iterate_over_permissions, r, target_permissions->ownerPerms, NULL);
		
		ap_rprintf(r, "\nGroup Permissions: "); 
		apr_table_do(iterate_over_permissions, r, target_permissions->groupPerms, NULL);
		
		ap_rprintf(r, "\nWorld Permissions: "); 
		apr_table_do(iterate_over_permissions, r, target_permissions->worldPerms, NULL);
	
		return OK;	

	} else {
        return DECLINED;
    }
}

static int provider_auth_check_user(request_rec *r)
{
    provider_test_config_rec *conf = ap_get_module_config(r->per_dir_config,
                                                        &authz_resource_module);
    if (conf->auth_required == 0) {
		ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"user_checker: Authn Not required");
    	return OK;
	}
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"user_checker: Authn required");
	return DECLINED;
}

static int provider_auth_checker(request_rec *r)
{
    provider_test_config_rec *conf = ap_get_module_config(r->per_dir_config,
                                                        &authz_resource_module);


	/*
	if (conf->auth_required == 0) {
		ap_log_rerror(APLOG_MARK, APLOG_ERR, NULL, r,"auth_checker: Authn Not required");
		return OK;
	}
	ap_log_rerror(APLOG_MARK, APLOG_ERR, NULL, r,"auth_checker: Authn required");
	*/


    int m = r->method_number;
    register int x;
    const char *t, *w, *res;
    const apr_array_header_t *reqs_arr = ap_requires(r);
	require_line *reqs;
	char *reason = NULL;
	apr_status_t status = 0;
    apr_table_t *groups = apr_table_make(r->pool, 15);
    //apr_table_t *authorized_methods = NULL;
	
    if (!reqs_arr) {
        return DECLINED;
    }

    reqs = (require_line *)reqs_arr->elts;
    for (x = 0; x < reqs_arr->nelts; x++) {

        /* if authoritative = On then break if a require already failed. */
        if (reason && conf->authoritative) {
            break;
        }

        if (!(reqs[x].method_mask & (AP_METHOD_BIT << m))) {
            continue;
        }

        t = reqs[x].requirement;
        w = ap_getword_white(r->pool, &t);

        if (!strcmp(w, "resource")) {
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
						  "Require matched 'resource'");
			
			if (conf->auth_required == 0) {
				ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"auth_checker: 1 Authn Not required");
				return OK;
			}
			
			
			/**
			 *
			 * HERE IS WHERE THE REAL CODE GOES
			 *
			 *
			 **/

			conf->authorized_methods = apr_table_copy(r->pool, conf->permissions->worldPerms);

			if (r->user != NULL) {
				authz_resource_grouplookup_provider *grouplookup_provider = loadGrouplookupProvider(r, conf);
				if (grouplookup_provider == NULL) {
					ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
								  "Group Lookup provider not set");
					return HTTP_INTERNAL_SERVER_ERROR;
				}
				
				status = grouplookup_provider->get_groups_by_username(r, &groups);
				if (status != APR_SUCCESS) {
					ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
								  "Could not retrieve group table");
					return HTTP_INTERNAL_SERVER_ERROR;
				}
				if (apr_table_elts(groups)->nelts == 0) {
					/* no groups available, so exit immediately */
					ap_rprintf(r, "user doesn't appear in group table");
					return HTTP_UNAUTHORIZED;
				}


				apr_table_setn(r->subprocess_env, "RESOURCE_OWNER", conf->permissions->owner);
				if (!strcmp(conf->permissions->owner, r->user)) {
					ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
								  "User %s is resource owner", r->user);
					apr_table_overlap(conf->authorized_methods, conf->permissions->ownerPerms, APR_OVERLAP_TABLES_SET);
				}
				ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
								  "User: %s  Resource owner: %s", r->user, conf->permissions->owner);

			} else {
					ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
								  "no user specified");				
			}
			
      
			apr_table_setn(r->subprocess_env, "RESOURCE_GROUP", conf->permissions->group);
			if (apr_table_get(groups, conf->permissions->group)) {
				ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
							  "User %s is member of resource group %s", r->user, conf->permissions->group);
      			apr_table_overlap(conf->authorized_methods, conf->permissions->groupPerms, APR_OVERLAP_TABLES_SET);
      		}
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
							  "Resource group: %s", conf->permissions->group);
      
			//apr_table_do(iterate_func, r, authorized_methods, NULL);
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
						  "HERE");
      		
			if (conf->auth_required == 0) {
				ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"auth_checker: Authn Not required");
				return OK;
			}
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"auth_checker: Authn required");

			if (res = apr_table_get(conf->authorized_methods, r->method)) {
				apr_table_setn(r->subprocess_env, "RESOURCE_ACCESS_LEVEL", res);
				return OK;
			}     
        }
	}	
	
    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
                  "Authorization of user %s to access %s failed, reason: %s",
                  r->user, r->uri, reason ? reason : "unknown");

    return HTTP_UNAUTHORIZED;
}


static int provider_access_checker(request_rec *r)
{

    if (ap_some_auth_required(r)) {
	    provider_test_config_rec *conf = ap_get_module_config(r->per_dir_config,
                                                        &authz_resource_module);
		apr_status_t status;

		authz_resource_permissions_provider *permissions_provider = loadPermissionsProvider(r, conf);
		if (permissions_provider == NULL) {
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
						  "Permissions provider not set");
			return HTTP_INTERNAL_SERVER_ERROR;
		}
	
		status = permissions_provider->get_permissions_by_uri(r, r->uri, &conf->permissions);
		if (status != APR_SUCCESS) {
			ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
						  "Could not retrieve permissions for %s", r->uri);
			conf->auth_required = 0;
			return OK;
		}

		//ap_log_rerror(APLOG_MARK, APLOG_ERR, NULL, r,"World Perms: %s", apr_table_get(conf->permissions->worldPerms, r->method));

		if (conf->permissions == NULL) {
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"Permissions not set");
			return OK;
		}
		
		if (apr_table_get(conf->permissions->worldPerms, r->method)) {
			conf->auth_required = 0;
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"access_checker: Authn Not required");
		} else {
			conf->auth_required = 1;		
			ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,"access_checker: Authn required");
		}
	}
    return OK;
}


static void authz_resource_register_hooks(apr_pool_t *p)
{
    ap_hook_handler(content_handler, NULL, NULL, APR_HOOK_MIDDLE);
	ap_hook_access_checker(provider_access_checker, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_check_user_id(provider_auth_check_user, NULL, NULL, APR_HOOK_FIRST);
	ap_hook_auth_checker(provider_auth_checker, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA authz_resource_module = {
    STANDARD20_MODULE_STUFF, 
    create_provider_test_dir_config,	/* create per-dir    config structures */
    NULL,                  				/* merge  per-dir    config structures */
    NULL,                  				/* create per-server config structures */
    NULL,                  				/* merge  per-server config structures */
    authz_resource_cmds,                 /* table of config file commands       */
    authz_resource_register_hooks  		/* register hooks                      */
};

